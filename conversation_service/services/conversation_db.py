from __future__ import annotations

"""Database utilities for conversation management."""

from datetime import datetime
from typing import List, Optional, Dict, Any
from typing import Dict, List, Optional

from sqlalchemy.orm import Session

from db_service.models.conversation import Conversation, ConversationTurn


class ConversationService:
    """Service layer for CRUD operations on conversations and turns."""

    def __init__(self, db: Session) -> None:
        self.db = db

    def get_or_create_conversation(
        self, user_id: int, conversation_id: Optional[str] = None
    ) -> Conversation:
        """Return an existing conversation for user or create a new one.

        Args:
            user_id: ID of the authenticated user.
            conversation_id: Optional public identifier of the conversation.

        Raises:
            PermissionError: If conversation exists but belongs to another user.
        """
        if conversation_id:
            conversation = (
                self.db.query(Conversation)
                .filter(Conversation.conversation_id == conversation_id)
                .first()
            )
            if conversation:
                if conversation.user_id != user_id:
                    raise PermissionError("Conversation does not belong to user")
                return conversation

        conversation = Conversation(user_id=user_id)
        if conversation_id:
            conversation.conversation_id = conversation_id
        try:
            self.db.add(conversation)
            self.db.commit()
            self.db.refresh(conversation)
            return conversation
        except Exception:
            self.db.rollback()
            raise

    def add_turn(
        self,
        conversation_id: str,
        user_id: int,
        user_message: str,
        assistant_response: str,
        processing_time_ms: float,
        intent_detected: Optional[str] = None,
        entities_extracted: Optional[List[Dict[str, Any]]] = None,
        agent_chain: Optional[List[str]] = None,
        search_results_count: Optional[int] = None,
        confidence_score: Optional[float] = None,

        confidence_score: Optional[float] = None,
        agent_chain: Optional[List[str]] = None,
        search_results_count: Optional[int] = None,
    ) -> ConversationTurn:
        """Persist a conversation turn and update conversation metadata."""

        conversation = (
            self.db.query(Conversation)
            .filter(
                Conversation.conversation_id == conversation_id,
                Conversation.user_id == user_id,
            )
            .first()
        )
        if conversation is None:
            raise ValueError("Conversation not found")
        entities_extracted: Optional[List[Dict]] = None,
        confidence_score: Optional[float] = None,
        agent_chain: Optional[List[str]] = None,
        search_results_count: int = 0,
        search_execution_time_ms: Optional[float] = None,
    ) -> ConversationTurn:
        """Persist a conversation turn and update conversation metadata.

        Args:
            conversation_id: Public identifier of the conversation.
            user_id: ID of the authenticated user.
            user_message: Message sent by the user.
            assistant_response: Response generated by the assistant.
            processing_time_ms: Processing time of the turn in milliseconds.
            intent_detected: Optional detected intent.
            entities_extracted: Optional list of extracted entities.
            confidence_score: Optional confidence score for the response.
            agent_chain: Optional list of agents involved in the processing.
            search_results_count: Number of results returned by search.
            search_execution_time_ms: Time taken to execute search, if any.

        Raises:
            ValueError: If the conversation is not found.
            PermissionError: If the conversation does not belong to the user.
        """

        conversation = (
            self.db.query(Conversation)
            .filter(Conversation.conversation_id == conversation_id)
            .first()
        )
        if not conversation:
            raise ValueError("Conversation not found")
        if conversation.user_id != user_id:
            raise PermissionError("Conversation does not belong to user")

        turn_number = conversation.total_turns + 1
        turn = ConversationTurn(
            conversation_id=conversation.id,
            turn_number=turn_number,
            user_message=user_message,
            assistant_response=assistant_response,
            processing_time_ms=processing_time_ms,
            intent_detected=intent_detected,
            entities_extracted=entities_extracted or [],
            agent_chain=agent_chain or [],
            search_results_count=search_results_count or 0,
            confidence_score=confidence_score,

            confidence_score=confidence_score,
            agent_chain=agent_chain or [],
            search_results_count=search_results_count or 0,
            search_results_count=search_results_count,
            search_execution_time_ms=search_execution_time_ms,
        )
        try:
            self.db.add(turn)
            conversation.total_turns = turn_number
            conversation.last_activity_at = datetime.utcnow()
            self.db.commit()
            self.db.refresh(turn)
            self.db.refresh(conversation)
            return turn
        except Exception:
            self.db.rollback()
            raise

    def list_conversations(self, user_id: int) -> List[Conversation]:
        """List all conversations for a user ordered by recent activity."""
        return (
            self.db.query(Conversation)
            .filter(Conversation.user_id == user_id)
            .order_by(Conversation.last_activity_at.desc())
            .all()
        )

    def get_turns(self, conversation: Conversation) -> List[ConversationTurn]:
        """Return ordered turns for a conversation."""
        return (
            self.db.query(ConversationTurn)
            .filter(ConversationTurn.conversation_id == conversation.id)
            .order_by(ConversationTurn.turn_number)
            .all()
        )
