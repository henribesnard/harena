"""
Metadata Service - Fournit les m√©tadonn√©es dynamiques aux agents
Injecte les cat√©gories et operation_types disponibles dans les prompts
"""
import sys
import os
import logging
from typing import Dict, List, Optional

# Ajouter le chemin parent pour importer enrichment_service
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))

try:
    from enrichment_service.category_service import CategoryService
    category_service_available = True
except ImportError:
    category_service_available = False
    logging.warning("CategoryService not available, using fallback metadata")

logger = logging.getLogger(__name__)


class MetadataService:
    """
    Service pour fournir les m√©tadonn√©es dynamiques aux agents

    Responsabilit√©s:
    - Charger les cat√©gories depuis la base (via CategoryService)
    - Fournir le mapping cat√©gories -> synonymes
    - G√©n√©rer les sections de prompt enrichies
    - Cache automatique (1h via CategoryService)
    """

    # Mapping des synonymes pour am√©liorer le matching
    # Ce mapping peut √™tre enrichi au fil du temps
    CATEGORY_SYNONYMS = {
        "Restaurant": ["restaurant", "restaurants", "resto", "restos", "restauration"],
        "Sant√©/pharmacie": [
            "sant√©", "sante", "pharmacie", "frais de sant√©", "frais de sante",
            "frais m√©dicaux", "medical", "m√©dical", "soins"
        ],
        "Virement sortants": [
            "virement", "virements", "virement sortant", "virements sortants",
            "transfert", "transferts"
        ],
        "Virement entrants": [
            "virement entrant", "virements entrants", "virement re√ßu",
            "virements re√ßus", "transfert re√ßu"
        ],
        "Retrait especes": [
            "retrait", "retraits", "retrait esp√®ces", "retrait especes",
            "retraits d'argent", "cash", "esp√®ces", "especes", "ATM"
        ],
        "Transport": [
            "transport", "transports", "d√©placement", "d√©placements",
            "mobilit√©", "mobilite"
        ],
        "Alimentation": [
            "alimentation", "courses", "alimentaire", "nourriture",
            "supermarch√©", "supermarche", "√©picerie", "epicerie"
        ],
        "Loisirs": [
            "loisirs", "loisir", "divertissement", "divertissements",
            "entertainment", "hobbies"
        ],
        "Abonnements": [
            "abonnement", "abonnements", "subscription", "subscriptions",
            "mensualit√©", "mensualites"
        ],
        "Ch√®ques √©mis": [
            "ch√®que", "cheque", "ch√®ques", "cheques", "check", "checks"
        ],
        "T√©l√©phones/internet": [
            "t√©l√©phone", "telephone", "internet", "mobile", "wifi",
            "t√©l√©phonie", "telephonie", "box internet"
        ],
        "V√™tements": [
            "v√™tement", "vetement", "v√™tements", "vetements",
            "habillement", "mode", "fringues"
        ],
        "Imp√¥ts": [
            "imp√¥t", "impot", "imp√¥ts", "impots", "taxe", "taxes",
            "fiscal", "fiscalit√©", "fiscalite"
        ],
        "Assurances": [
            "assurance", "assurances", "insurance", "cotisation", "cotisations"
        ],
        "Carburant": [
            "carburant", "essence", "diesel", "gasoil", "gas-oil",
            "fuel", "station-service", "station service"
        ],
        "Frais bancaires": [
            "frais bancaire", "frais bancaires", "commission", "commissions",
            "frais de tenue de compte", "agios"
        ],
    }

    # Operation types disponibles
    # Ces valeurs correspondent aux valeurs exactes dans la base
    OPERATION_TYPES = {
        "Carte": ["carte", "carte bancaire", "CB", "card", "paiement carte"],
        "Pr√©l√®vement": ["pr√©l√®vement", "prelevement", "direct debit", "pr√©levement"],
        "Virement": ["virement", "transfer", "transfert"],
        "Ch√®que": ["ch√®que", "cheque", "check"],
        "Retrait": ["retrait", "withdrawal", "ATM", "distributeur"],
    }

    def __init__(self):
        if category_service_available:
            self.category_service = CategoryService()
            logger.info("MetadataService initialized with CategoryService")
        else:
            self.category_service = None
            logger.warning("MetadataService initialized without CategoryService (using fallback)")

    def get_all_categories(self) -> Dict[int, any]:
        """R√©cup√®re toutes les cat√©gories disponibles"""
        if self.category_service:
            try:
                return self.category_service.get_all_categories()
            except Exception as e:
                logger.error(f"Error fetching categories: {e}")
                return {}
        return {}

    def get_categories_prompt_section(self) -> str:
        """
        G√©n√®re la section du prompt avec les cat√©gories disponibles

        Returns:
            str: Section de prompt format√©e avec toutes les cat√©gories et leurs synonymes
        """
        categories = self.get_all_categories()

        if not categories:
            logger.warning("No categories available, returning empty prompt section")
            return ""

        prompt = "\n" + "=" * 80 + "\n"
        prompt += "## CAT√âGORIES DISPONIBLES EN BASE\n"
        prompt += "=" * 80 + "\n"
        prompt += "Utilise UNIQUEMENT ces cat√©gories exactes lors de la construction des filtres.\n"
        prompt += "Ne jamais inventer de cat√©gories, utiliser EXACTEMENT les noms ci-dessous.\n\n"

        # Grouper par groupe
        by_group = {}
        for cat_id, cat in categories.items():
            group = cat.group_name or "Autres"
            if group not in by_group:
                by_group[group] = []
            by_group[group].append(cat)

        # Afficher par groupe
        for group_name in sorted(by_group.keys()):
            cats = by_group[group_name]
            prompt += f"\n### üìÅ {group_name}\n"

            for cat in sorted(cats, key=lambda x: x.category_name):
                # Nom exact de la cat√©gorie
                prompt += f"- **`{cat.category_name}`**"

                # Ajouter les synonymes si disponibles
                synonyms = self.CATEGORY_SYNONYMS.get(cat.category_name, [])
                if synonyms:
                    prompt += f"\n  ‚Üí Synonymes: {', '.join(synonyms)}"

                prompt += "\n"

        # Instructions de mapping
        prompt += "\n" + "=" * 80 + "\n"
        prompt += "## R√àGLES DE MAPPING DES REQU√äTES UTILISATEUR\n"
        prompt += "=" * 80 + "\n\n"

        prompt += """**IMPORTANT - Comment mapper les requ√™tes utilisateur vers les cat√©gories:**

1. **Normalisation des pluriels et variantes:**
   - "restaurants" ‚Üí utilise **`Restaurant`**
   - "virements" ‚Üí utilise **`Virement sortants`** (si contexte = d√©penses/d√©bit)
   - "retraits", "retrait d'argent" ‚Üí utilise **`Retrait especes`**
   - "sant√©", "frais de sant√©" ‚Üí utilise **`Sant√©/pharmacie`**
   - "transports" ‚Üí utilise **`Transport`**

2. **Recherche intelligente:**
   - D'abord chercher une correspondance EXACTE dans les noms de cat√©gories
   - Ensuite utiliser les synonymes ci-dessus
   - G√©rer les accents : "sante" = "sant√©"
   - G√©rer les pluriels : "restaurants" = "restaurant"

3. **Si aucune cat√©gorie ne correspond:**
   - NE PAS filtrer sur category_name
   - Utiliser la recherche textuelle sur merchant_name et primary_description
   - Exemple: si l'utilisateur cherche "pizza" et qu'il n'y a pas de cat√©gorie "pizza",
     faire une recherche textuelle au lieu d'utiliser une cat√©gorie approximative

4. **Contexte des virements:**
   - "mes virements" sans contexte ‚Üí **`Virement sortants`** (d√©penses)
   - "virements re√ßus" ‚Üí **`Virement entrants`** (revenus)
   - Toujours ajouter le filtre transaction_type appropri√© (debit/credit)

5. **Format des filtres category_name:**
   ```json
   // Pour correspondance exacte (pr√©f√©r√© si cat√©gorie connue)
   "category_name": {"term": "Restaurant"}

   // Pour recherche floue (si variante incertaine)
   "category_name": {"match": "Restaurant"}

   // Pour plusieurs cat√©gories
   "category_name": {"terms": ["Restaurant", "Alimentation"]}
   ```

**R√àGLE D'OR:** Toujours utiliser le nom EXACT de la cat√©gorie tel qu'il appara√Æt dans la liste ci-dessus.
Ne JAMAIS utiliser les synonymes dans les filtres, uniquement les noms exacts.
"""

        return prompt

    def get_operation_types_prompt_section(self) -> str:
        """
        G√©n√®re la section du prompt avec les operation_types disponibles

        Returns:
            str: Section de prompt format√©e avec les operation_types
        """
        prompt = "\n" + "=" * 80 + "\n"
        prompt += "## OPERATION_TYPES DISPONIBLES\n"
        prompt += "=" * 80 + "\n"
        prompt += "Types d'op√©rations bancaires disponibles dans la base:\n\n"

        for op_type, synonyms in self.OPERATION_TYPES.items():
            prompt += f"- **`{op_type}`**\n"
            if synonyms:
                prompt += f"  ‚Üí Synonymes: {', '.join(synonyms)}\n"

        prompt += """
**Usage des operation_types:**

‚ö†Ô∏è IMPORTANT: Les cat√©gories sont g√©n√©ralement plus pr√©cises que les operation_types.
Privil√©gier l'utilisation des cat√©gories sauf si l'utilisateur demande explicitement un type d'op√©ration.

Exemples:
- "mes paiements par carte" ‚Üí operation_type: "Carte"
- "tous mes pr√©l√®vements" ‚Üí operation_type: "Pr√©l√®vement"
- "mes virements" ‚Üí pr√©f√©rer category_name: "Virement sortants" + transaction_type: "debit"

Note: Les retraits et virements sont mieux g√©r√©s par les cat√©gories que par operation_type.
"""
        return prompt

    def get_transaction_types_prompt_section(self) -> str:
        """
        G√©n√®re la section du prompt avec les transaction_types

        Returns:
            str: Section de prompt format√©e avec les transaction_types
        """
        prompt = "\n" + "=" * 80 + "\n"
        prompt += "## TRANSACTION_TYPES (d√©j√† bien g√©r√©)\n"
        prompt += "=" * 80 + "\n\n"

        prompt += """**Valeurs possibles:**
- **`debit`**: D√©penses, sorties d'argent (amount n√©gatif dans la base)
- **`credit`**: Revenus, entr√©es d'argent (amount positif dans la base)

**Mapping des requ√™tes utilisateur:**
- "d√©penses", "achats", "sorties" ‚Üí transaction_type: "debit"
- "revenus", "salaire", "entr√©es", "virements re√ßus" ‚Üí transaction_type: "credit"
- "mes virements" (sans pr√©cision) ‚Üí par d√©faut transaction_type: "debit" (virements sortants)

**Important:**
- Toujours utiliser transaction_type pour diff√©rencier d√©penses/revenus
- Ne pas confondre avec operation_type qui indique le moyen de paiement
"""
        return prompt

    def get_full_metadata_prompt(self) -> str:
        """
        Retourne le prompt complet avec toutes les m√©tadonn√©es

        Returns:
            str: Prompt complet format√© incluant toutes les m√©tadonn√©es
        """
        sections = [
            self.get_categories_prompt_section(),
            self.get_operation_types_prompt_section(),
            self.get_transaction_types_prompt_section()
        ]

        return "\n".join(section for section in sections if section)

    def search_category_by_name(self, query: str) -> Optional[str]:
        """
        Recherche une cat√©gorie par nom ou synonyme

        Args:
            query: Nom ou synonyme de cat√©gorie recherch√©

        Returns:
            str: Nom exact de la cat√©gorie ou None si non trouv√©e
        """
        if not query:
            return None

        query_lower = query.lower().strip()

        # R√©cup√©rer toutes les cat√©gories
        categories = self.get_all_categories()

        # Si CategoryService est disponible, utiliser la base de donn√©es
        if categories:
            # 1. Recherche exacte (insensible √† la casse)
            for cat_id, cat in categories.items():
                if cat.category_name.lower() == query_lower:
                    return cat.category_name

            # 2. Recherche dans les synonymes avec validation en base
            for category_name, synonyms in self.CATEGORY_SYNONYMS.items():
                if query_lower in [s.lower() for s in synonyms]:
                    # V√©rifier que cette cat√©gorie existe bien en base
                    for cat_id, cat in categories.items():
                        if cat.category_name == category_name:
                            return category_name

            # 3. Recherche partielle dans les noms de cat√©gories
            for cat_id, cat in categories.items():
                if query_lower in cat.category_name.lower():
                    return cat.category_name

        # MODE FALLBACK : Si CategoryService n'est pas disponible
        # Utiliser uniquement CATEGORY_SYNONYMS (hardcod√©)
        else:
            logger.debug(f"Using fallback mode for category search: {query}")

            # 1. Recherche exacte dans les cl√©s de CATEGORY_SYNONYMS
            for category_name in self.CATEGORY_SYNONYMS.keys():
                if category_name.lower() == query_lower:
                    return category_name

            # 2. Recherche dans les synonymes
            for category_name, synonyms in self.CATEGORY_SYNONYMS.items():
                if query_lower in [s.lower() for s in synonyms]:
                    return category_name

            # 3. Recherche partielle dans les cl√©s
            for category_name in self.CATEGORY_SYNONYMS.keys():
                if query_lower in category_name.lower():
                    return category_name

        # Aucune correspondance trouv√©e
        logger.warning(f"No category found for query: {query}")
        return None


# Instance singleton
metadata_service = MetadataService()


# Pour debug/test
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    service = MetadataService()

    print("\n" + "=" * 80)
    print("METADATA SERVICE - TEST")
    print("=" * 80)

    # Test r√©cup√©ration cat√©gories
    categories = service.get_all_categories()
    print(f"\n‚úì {len(categories)} categories loaded from database")

    # Test g√©n√©ration prompt
    prompt = service.get_full_metadata_prompt()
    print(f"\n‚úì Generated prompt ({len(prompt)} chars)")
    print("\nPrompt preview (first 1000 chars):")
    print(prompt[:1000])

    # Test recherche
    print("\n" + "=" * 80)
    print("CATEGORY SEARCH TESTS")
    print("=" * 80)

    test_queries = [
        "restaurant", "restaurants", "sant√©", "sante", "frais de sant√©",
        "virement", "virements", "retrait", "retraits d'argent", "transport"
    ]

    for query in test_queries:
        result = service.search_category_by_name(query)
        status = "‚úì" if result else "‚úó"
        print(f"{status} '{query}' -> {result}")
