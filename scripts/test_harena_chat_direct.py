"""
Test minimal pour Harena : login ‚Üí chat ‚Üí analyse du workflow.
ANALYSE PURE : r√©cup√®re et affiche les donn√©es internes de l'agent sans refaire de recherche.
"""

import base64
import json
import requests
from datetime import datetime

BASE_URL = "http://localhost:8000/api/v1"
USERNAME = "test2@example.com"
PASSWORD = "password123"
QUESTION = "Transactions sup√©rieures √† 100 euros"

def _decode_jwt(token: str) -> dict:
    """D√©codage manuel du payload JWT (sans v√©rification de signature)."""
    payload = token.split(".")[1]
    padding = "=" * (-len(payload) % 4)
    return json.loads(base64.urlsafe_b64decode(payload + padding).decode())

def main() -> None:
    session = requests.Session()

    # ----- AUTHENTIFICATION --------------------------------------------------
    data = f"username={USERNAME}&password={PASSWORD}"
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    resp = session.post(f"{BASE_URL}/users/auth/login", data=data, headers=headers)
    resp.raise_for_status()
    token = resp.json()["access_token"]
    print("‚úÖ OK client authentifi√©")

    session.headers.update({"Authorization": f"Bearer {token}"})
    user_id = int(_decode_jwt(token)["sub"])

    # ----- CONVERSATION AVEC L'AGENT ----------------------------------------
    chat_payload = {"message": QUESTION, "conversation_id": "test-chat-analysis"}
    chat_resp = session.post(f"{BASE_URL}/conversation/chat", json=chat_payload)
    chat_resp.raise_for_status()
    chat_data = chat_resp.json()
    
    print("‚úÖ Conversation r√©ussie")
    print(f"üó®Ô∏è Question pos√©e : {QUESTION}")
    print(f"üí¨ R√©ponse g√©n√©r√©e : {chat_data['message']}")
    print()

    # ----- ANALYSE DE L'INTENTION D√âTECT√âE ----------------------------------
    intent_result = chat_data["metadata"]["intent_result"]
    print("üß† ANALYSE DE L'INTENTION :")
    print(f"   üéØ Type : {intent_result['intent_type']}")
    print(f"   üé≤ Confiance : {intent_result.get('confidence', 'N/A')}")
    print(f"   ‚ö° M√©thode : {intent_result.get('method', 'N/A')}")
    print()

    # ----- ANALYSE DES ENTIT√âS EXTRAITES -----------------------------------
    entities = intent_result.get('entities', [])
    print("üß© ENTIT√âS EXTRAITES :")
    if entities:
        for i, entity in enumerate(entities, 1):
            print(f"   {i}. {entity['entity_type']} :")
            print(f"      üìù Valeur brute : '{entity['raw_value']}'")
            print(f"      üîÑ Valeur normalis√©e : '{entity['normalized_value']}'")
            print(f"      üéØ Confiance : {entity['confidence']}")
            print(f"      üîç M√©thode : {entity.get('detection_method', 'N/A')}")
            print(f"      üìç Position : {entity.get('start_position', '?')}-{entity.get('end_position', '?')}")
    else:
        print("   ‚ùå Aucune entit√© d√©tect√©e")
    print()

    # ----- ANALYSE DU TYPE D'AGENT UTILIS√â ----------------------------------
    metrics_resp = session.get(f"{BASE_URL}/conversation/metrics")
    metrics_resp.raise_for_status()
    metrics_data = metrics_resp.json()
    
    print("ü§ñ AGENTS UTILIS√âS :")
    agent_perf = metrics_data.get("agent_metrics", {}).get("agent_performance", {})
    
    if "intent_agent" in agent_perf:
        intent_agent = agent_perf["intent_agent"]
        agent_type = intent_agent.get("agent_type", "Unknown")
        print(f"   üß† Agent d'intention : {agent_type}")
        
        if agent_type == "MockIntentAgent":
            print("      ‚úÖ Mock agent utilis√© (mode test)")
        else:
            print(f"      ‚ÑπÔ∏è  Agent r√©el utilis√© : {agent_type}")
    
    # Autres agents
    for agent_name, agent_data in agent_perf.items():
        if agent_name != "intent_agent":
            print(f"   üîß {agent_name} : {agent_data.get('agent_type', 'Unknown')}")
    print()

    # ----- ANALYSE DE LA RECHERCHE EFFECTU√âE --------------------------------
    print("üîç ANALYSE DE LA RECHERCHE :")
    
    # Extraire les informations de recherche depuis les m√©tadonn√©es
    metadata = chat_data.get("metadata", {})
    workflow_data = metadata.get("workflow_data", {})

    search_results_count = 0
    if isinstance(workflow_data, dict):
        # Priorit√© √† la cl√© directe fournie par l'orchestrateur
        if isinstance(workflow_data.get("search_results_count"), int):
            search_results_count = workflow_data["search_results_count"]
        else:
            # R√©trocompatibilit√© : calculer √† partir de la structure d√©taill√©e
            sr = workflow_data.get("search_results")
            if isinstance(sr, dict):
                search_response = sr.get("metadata", {}).get("search_response", {})
                results = search_response.get("results") if isinstance(search_response, dict) else None
                if isinstance(results, list):
                    search_results_count = len(results)
            elif isinstance(sr, list):
                search_results_count = len(sr)

    print(f"   üìä R√©sultats trouv√©s par l'agent : {search_results_count}")
    
    # Analyser les entit√©s pour comprendre la requ√™te g√©n√©r√©e
    merchant = None
    date_filter = None
    
    for entity in entities:
        if entity['entity_type'] == 'MERCHANT':
            merchant = entity['normalized_value']
        elif entity['entity_type'] in ['RELATIVE_DATE', 'DATE']:
            date_filter = entity['normalized_value']
    
    print(f"   üè™ Marchand recherch√© : {merchant or 'N/A'}")
    print(f"   üìÖ Filtre temporel : {date_filter or 'N/A'}")
    
    # D√©duire la requ√™te probable de l'agent
    if date_filter == 'current_month':
        now = datetime.now()
        expected_filter = f"{now.year}-{now.month:02d}-01 √† {now.year}-{now.month:02d}-31"
        print(f"   üóìÔ∏è  P√©riode d√©duite : {expected_filter}")
    
    print()

    # ----- ANALYSE DES PERFORMANCES -----------------------------------------
    processing_time = chat_data.get("processing_time_ms", 0)
    print("‚ö° PERFORMANCES :")
    print(f"   ‚è±Ô∏è  Temps total : {processing_time}ms")
    
    if "orchestrator_performance" in metrics_data.get("agent_metrics", {}):
        orch_perf = metrics_data["agent_metrics"]["orchestrator_performance"]
        exec_times = orch_perf.get("execution_times", {})
        print(f"   üé≠ Temps moyen orchestrateur : {exec_times.get('average_ms', 'N/A')}ms")
    
    # Temps par agent
    for agent_name, agent_data in agent_perf.items():
        exec_times = agent_data.get("execution_times", {})
        avg_time = exec_times.get("average_ms", 0)
        if avg_time > 0:
            print(f"   üîß {agent_name} : {avg_time}ms")
    print()

    # ----- ANALYSE DE LA QUALIT√â DE LA R√âPONSE ------------------------------
    response_text = chat_data['message']
    print("‚ú® ANALYSE DE LA R√âPONSE :")
    print(f"   üìè Longueur : {len(response_text)} caract√®res")
    print(f"   üî§ Mots : ~{len(response_text.split())} mots")
    
    # Indicateurs de qualit√©
    quality_indicators = {
        "Structure markdown": "**" in response_text or "#" in response_text,
        "Actions sugg√©r√©es": "Actions sugg√©r√©es" in response_text or "suggestions" in response_text.lower(),
        "Insights/Observations": "insights" in response_text.lower() or "observations" in response_text.lower(),
        "Liens/r√©f√©rences": "http" in response_text or "www." in response_text,
        "Contextualisation temporelle": any(month in response_text.lower() for month in ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'])
    }
    
    print("   üìã Indicateurs de qualit√© :")
    for indicator, present in quality_indicators.items():
        status = "‚úÖ" if present else "‚ùå"
        print(f"      {status} {indicator}")
    print()

    # ----- R√âSUM√â EX√âCUTIF ---------------------------------------------------
    print("üìã R√âSUM√â EX√âCUTIF :")
    print(f"   üéØ Intention correctement d√©tect√©e : {'‚úÖ' if intent_result['intent_type'] == 'SEARCH_BY_AMOUNT' else '‚ùå'}")
    print(f"   üß© Entit√©s extraites : {'‚úÖ' if len(entities) > 0 else '‚ùå'}")
    print(f"   üîç Recherche ex√©cut√©e : {'‚úÖ' if 'search_results_count' in chat_data['metadata'] else '‚ùå'}")
    print(f"   üí¨ R√©ponse g√©n√©r√©e : {'‚úÖ' if len(response_text) > 50 else '‚ùå'}")
    print(f"   ‚ö° Performance acceptable : {'‚úÖ' if processing_time < 30000 else '‚ùå'} ({processing_time}ms)")
    
    # Coh√©rence globale
    coherence_score = sum([
        intent_result['intent_type'] == 'SEARCH_BY_AMOUNT',
        len(entities) > 0,
        'search_results_count' in chat_data['metadata'],
        len(response_text) > 50,
        processing_time < 30000
    ])
    
    print(f"   üèÜ Score de coh√©rence : {coherence_score}/5")
    
    if coherence_score >= 4:
        print("   üéâ Workflow fonctionnel et coh√©rent !")
    elif coherence_score >= 3:
        print("   ‚ö†Ô∏è  Workflow fonctionnel avec am√©liorations possibles")
    else:
        print("   ‚ùå Probl√®mes d√©tect√©s dans le workflow")

if __name__ == "__main__":
    main()