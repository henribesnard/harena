"""
Client Qdrant avec logging am√©lior√© pour la recherche s√©mantique.
"""
import logging
import time
from typing import List, Dict, Any, Optional
from qdrant_client import AsyncQdrantClient
from qdrant_client.models import Filter, FieldCondition, Match, Range, PointStruct, VectorParams, Distance
from qdrant_client.http.exceptions import ResponseHandlingException, UnexpectedResponse

from config_service.config import settings

# Configuration des loggers
logger = logging.getLogger("search_service.qdrant")
metrics_logger = logging.getLogger("search_service.metrics.qdrant")


class QdrantClient:
    """Client Qdrant avec logging am√©lior√© pour la recherche s√©mantique."""
    
    def __init__(self):
        self.client = None
        self.collection_name = "financial_transactions"
        self._initialized = False
        self._connection_attempts = 0
        self._last_health_check = None
        self._collection_info = None
        
    async def initialize(self):
        """Initialise la connexion Qdrant avec logging d√©taill√©."""
        logger.info("üîÑ Initialisation du client Qdrant...")
        start_time = time.time()
        
        if not settings.QDRANT_URL:
            logger.error("‚ùå QDRANT_URL non configur√©e")
            return False
        
        # Log de la configuration (masquer API key)
        safe_url = self._mask_api_key(settings.QDRANT_URL)
        logger.info(f"üîó Connexion √† Qdrant: {safe_url}")
        
        if settings.QDRANT_API_KEY:
            logger.info("üîë Authentification API key configur√©e")
        else:
            logger.info("üîì Connexion sans authentification")
        
        try:
            self._connection_attempts += 1
            logger.info(f"üîÑ Tentative de connexion #{self._connection_attempts}")
            
            # Cr√©er le client
            connection_start = time.time()
            
            if settings.QDRANT_API_KEY:
                self.client = AsyncQdrantClient(
                    url=settings.QDRANT_URL,
                    api_key=settings.QDRANT_API_KEY,
                    timeout=30.0
                )
            else:
                self.client = AsyncQdrantClient(
                    url=settings.QDRANT_URL,
                    timeout=30.0
                )
            
            # Test de connexion
            logger.info("‚è±Ô∏è Test de connexion Qdrant...")
            collections = await self.client.get_collections()
            
            connection_time = time.time() - connection_start
            total_time = time.time() - start_time
            
            # V√©rification des collections
            collection_names = [col.name for col in collections.collections]
            logger.info(f"‚úÖ Connexion Qdrant r√©ussie en {connection_time:.3f}s")
            logger.info(f"üìö Collections disponibles: {len(collection_names)}")
            
            for col_name in collection_names:
                logger.info(f"   - {col_name}")
            
            # V√©rifier si notre collection existe
            if self.collection_name in collection_names:
                logger.info(f"‚úÖ Collection '{self.collection_name}' trouv√©e")
                # Obtenir les infos de la collection
                try:
                    collection_info = await self.client.get_collection(self.collection_name)
                    self._collection_info = {
                        "vectors_count": collection_info.vectors_count,
                        "indexed_vectors_count": collection_info.indexed_vectors_count,
                        "points_count": collection_info.points_count,
                        "segments_count": collection_info.segments_count,
                        "status": collection_info.status
                    }
                    logger.info(f"üìä Collection '{self.collection_name}': {collection_info.points_count} points")
                except Exception as collection_error:
                    logger.warning(f"‚ö†Ô∏è Erreur r√©cup√©ration infos collection: {collection_error}")
            else:
                logger.warning(f"‚ö†Ô∏è Collection '{self.collection_name}' non trouv√©e")
                logger.info("üí° La collection sera cr√©√©e lors du premier enrichissement")
            
            # Marquer comme initialis√©
            self._initialized = True
            logger.info(f"üéâ Client Qdrant pr√™t en {total_time:.3f}s")
            
            return True
            
        except Exception as e:
            connection_time = time.time() - start_time
            self._handle_connection_error(e, connection_time)
            return False
    
    def _mask_api_key(self, url: str) -> str:
        """Masque l'API key dans l'URL pour les logs."""
        # Qdrant URL est g√©n√©ralement juste l'endpoint, pas de credentials dans l'URL
        return url
    
    def _handle_connection_error(self, error, connection_time):
        """G√®re les erreurs de connexion avec diagnostic d√©taill√©."""
        error_type = error.__class__.__name__
        error_msg = str(error)
        
        logger.error(f"üí• Erreur Qdrant apr√®s {connection_time:.3f}s:")
        logger.error(f"   Type: {error_type}")
        logger.error(f"   Message: {error_msg}")
        
        # Diagnostic sp√©cifique des erreurs
        error_str = error_msg.lower()
        if "connection" in error_str or "timeout" in error_str:
            logger.error("üîå DIAGNOSTIC: Probl√®me de connectivit√© r√©seau")
            logger.error("   - V√©rifiez l'URL Qdrant")
            logger.error("   - V√©rifiez la connectivit√© r√©seau")
        elif "401" in error_msg or "403" in error_msg or "auth" in error_str:
            logger.error("üîë DIAGNOSTIC: Probl√®me d'authentification")
            logger.error("   - V√©rifiez QDRANT_API_KEY")
        elif "ssl" in error_str or "certificate" in error_str:
            logger.error("üîí DIAGNOSTIC: Probl√®me SSL/TLS")
        
        # Suggestions de diagnostic
        logger.error("üîß Actions de diagnostic sugg√©r√©es:")
        logger.error("   - V√©rifier la connectivit√© r√©seau vers Qdrant")
        logger.error("   - Valider QDRANT_URL et QDRANT_API_KEY")
        logger.error("   - Contr√¥ler l'√©tat du service Qdrant")
    
    def _handle_response_error(self, error):
        """G√®re les erreurs de r√©ponse avec diagnostic."""
        status_code = getattr(error, 'status_code', 'unknown')
        error_type = error.__class__.__name__
        error_msg = str(error)
        
        logger.error("üö´ Diagnostic de l'erreur Qdrant:")
        logger.error(f"   - Type: {error_type}")
        logger.error(f"   - Status: {status_code}")
        logger.error(f"   - Message: {error_msg}")
        
        # Diagnostic selon le code d'erreur
        if status_code == 401:
            logger.error("üîë Erreur d'authentification - v√©rifier QDRANT_API_KEY")
        elif status_code == 403:
            logger.error("üö´ Acc√®s refus√© - v√©rifier les permissions")
        elif status_code == 404:
            logger.error("‚ùå Ressource non trouv√©e - v√©rifier le nom de la collection")
        elif status_code == 429:
            logger.error("üêå Rate limiting - r√©duire la fr√©quence des requ√™tes")
        elif status_code >= 500:
            logger.error("üö® Erreur serveur Qdrant - probl√®me c√¥t√© serveur")
        
        # Suggestions de diagnostic
        logger.error("üîß Actions de diagnostic sugg√©r√©es:")
        logger.error("   - V√©rifier la connectivit√© r√©seau vers Qdrant")
        logger.error("   - Valider QDRANT_URL et QDRANT_API_KEY")
        logger.error("   - Contr√¥ler l'√©tat du service Qdrant")
        logger.error("   - V√©rifier que la collection existe")
    
    async def is_healthy(self) -> bool:
        """V√©rifie si le client est sain et fonctionnel."""
        if not self.client or not self._initialized:
            return False
        
        try:
            # Test rapide de connexion
            start_time = time.time()
            collections = await self.client.get_collections()
            response_time = time.time() - start_time
            
            is_healthy = len(collections.collections) >= 0  # Au moins le service r√©pond
            
            # Mettre √† jour le cache de sant√©
            self._last_health_check = {
                "timestamp": time.time(),
                "healthy": is_healthy,
                "response_time": response_time,
                "collections_count": len(collections.collections)
            }
            
            return is_healthy
            
        except Exception as e:
            logger.error(f"‚ùå Health check failed: {e}")
            return False
    
    async def search(
        self,
        query_vector: List[float],
        user_id: int,
        limit: int = 10,
        filters: Dict[str, Any] = None
    ) -> List[Dict[str, Any]]:
        """Effectue une recherche vectorielle avec logging des performances."""
        if not self.client or not self._initialized:
            raise RuntimeError("Client Qdrant non initialis√©")
        
        search_id = f"search_{int(time.time() * 1000)}"
        logger.info(f"üéØ [{search_id}] Recherche vectorielle pour user {user_id} (limit: {limit})")
        
        start_time = time.time()
        
        try:
            # Construire le filtre pour l'utilisateur
            search_filter = Filter(
                must=[
                    FieldCondition(
                        key="user_id",
                        match=Match(value=user_id)
                    )
                ]
            )
            
            # Ajouter des filtres suppl√©mentaires si sp√©cifi√©s
            if filters:
                for field, value in filters.items():
                    if value is not None:
                        if isinstance(value, (int, float)):
                            # Filtre num√©rique
                            search_filter.must.append(
                                FieldCondition(
                                    key=field,
                                    match=Match(value=value)
                                )
                            )
                        elif isinstance(value, str):
                            # Filtre texte
                            search_filter.must.append(
                                FieldCondition(
                                    key=field,
                                    match=Match(value=value)
                                )
                            )
                        elif isinstance(value, dict) and ("gte" in value or "lte" in value):
                            # Filtre de plage
                            search_filter.must.append(
                                FieldCondition(
                                    key=field,
                                    range=Range(
                                        gte=value.get("gte"),
                                        lte=value.get("lte")
                                    )
                                )
                            )
            
            # Ex√©cuter la recherche
            logger.info(f"üéØ [{search_id}] Ex√©cution recherche vectorielle...")
            query_start = time.time()
            
            # Utiliser query_points au lieu de search (deprecated)
            try:
                search_result = await self.client.query_points(
                    collection_name=self.collection_name,
                    query=query_vector,
                    query_filter=search_filter,
                    limit=limit,
                    with_payload=True,
                    with_vectors=False  # Pas besoin des vecteurs en retour
                )
            except AttributeError:
                # Fallback pour les versions plus anciennes
                search_result = await self.client.search(
                    collection_name=self.collection_name,
                    query_vector=query_vector,
                    query_filter=search_filter,
                    limit=limit,
                    with_payload=True,
                    with_vectors=False
                )
            
            query_time = time.time() - query_start
            total_time = time.time() - start_time
            
            # Analyser les r√©sultats
            results = []
            scores = []
            
            for point in search_result.points if hasattr(search_result, 'points') else search_result:
                result_data = {
                    "id": str(point.id),
                    "score": float(point.score),
                    "payload": point.payload
                }
                results.append(result_data)
                scores.append(point.score)
            
            # M√©triques de performance
            avg_score = sum(scores) / len(scores) if scores else 0
            min_score = min(scores) if scores else 0
            max_score = max(scores) if scores else 0
            
            # Logging des r√©sultats
            logger.info(f"‚úÖ [{search_id}] Recherche termin√©e:")
            logger.info(f"   - Temps total: {total_time:.3f}s")
            logger.info(f"   - Temps requ√™te: {query_time:.3f}s")
            logger.info(f"   - R√©sultats: {len(results)}/{limit}")
            logger.info(f"   - Score moyen: {avg_score:.3f}")
            
            if len(results) > 0:
                logger.info(f"   - Score min/max: {min_score:.3f}/{max_score:.3f}")
            
            # M√©triques pour monitoring
            metrics_logger.info("qdrant_search", extra={
                "search_id": search_id,
                "user_id": user_id,
                "query_time": query_time,
                "total_time": total_time,
                "results_count": len(results),
                "requested_limit": limit,
                "avg_score": avg_score,
                "filters_count": len(filters) if filters else 0
            })
            
            return results
            
        except ResponseHandlingException as e:
            search_time = time.time() - start_time
            logger.error(f"‚ùå [{search_id}] Erreur Qdrant apr√®s {search_time:.3f}s:")
            self._handle_response_error(e)
            raise
        except Exception as e:
            search_time = time.time() - start_time
            error_type = e.__class__.__name__
            logger.error(f"‚ùå [{search_id}] Erreur g√©n√©rale apr√®s {search_time:.3f}s:")
            logger.error(f"   Type: {error_type}")
            logger.error(f"   Message: {str(e)}")
            raise
    
    async def get_collections(self):
        """Retourne la liste des collections disponibles."""
        if not self.client or not self._initialized:
            raise RuntimeError("Client Qdrant non initialis√©")
        
        try:
            collections = await self.client.get_collections()
            return [col.name for col in collections.collections]
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration collections: {e}")
            raise
    
    async def collection_exists(self, collection_name: str = None) -> bool:
        """V√©rifie si une collection existe."""
        collection_name = collection_name or self.collection_name
        
        try:
            collections = await self.get_collections()
            return collection_name in collections
        except Exception:
            return False
    
    async def get_collection_info(self, collection_name: str = None) -> Dict[str, Any]:
        """Retourne les informations d√©taill√©es d'une collection."""
        collection_name = collection_name or self.collection_name
        
        if not self.client or not self._initialized:
            raise RuntimeError("Client Qdrant non initialis√©")
        
        try:
            collection_info = await self.client.get_collection(collection_name)
            return {
                "name": collection_name,
                "vectors_count": collection_info.vectors_count,
                "indexed_vectors_count": collection_info.indexed_vectors_count,
                "points_count": collection_info.points_count,
                "segments_count": collection_info.segments_count,
                "status": collection_info.status.value if hasattr(collection_info.status, 'value') else str(collection_info.status),
                "optimizer_status": collection_info.optimizer_status.value if hasattr(collection_info.optimizer_status, 'value') else str(collection_info.optimizer_status)
            }
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration infos collection '{collection_name}': {e}")
            raise
    
    async def close(self):
        """Ferme la connexion Qdrant."""
        if self.client:
            try:
                await self.client.close()
                logger.info("‚úÖ Connexion Qdrant ferm√©e proprement")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur fermeture Qdrant: {e}")
            finally:
                self.client = None
                self._initialized = False
    
    def get_status(self) -> Dict[str, Any]:
        """Retourne le statut complet du client."""
        return {
            "initialized": self._initialized,
            "connection_attempts": self._connection_attempts,
            "last_health_check": self._last_health_check,
            "collection_name": self.collection_name,
            "collection_info": self._collection_info
        }