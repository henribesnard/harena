"""
Fonctions d'initialisation am√©lior√©es pour les services de recherche.

Ce module contient les fonctions d'initialisation corrig√©es pour les clients
Elasticsearch (Bonsai) et Qdrant avec gestion d'erreur robuste.
"""

import asyncio
import logging
import time
from typing import Dict, Any, Optional, Tuple, List

from config_service.config import settings

logger = logging.getLogger("search_service.initialization")


async def initialize_elasticsearch_hybrid() -> Tuple[bool, Optional[Any], Dict[str, Any]]:
    """
    Initialise et teste la connexion Elasticsearch hybride (client standard + Bonsai HTTP).
    
    Returns:
        Tuple[bool, Optional[HybridElasticClient], Dict[str, Any]]: (succ√®s, client, diagnostic)
    """
    logger.info("üîç === INITIALISATION ELASTICSEARCH HYBRIDE ===")
    diagnostic = {
        "service": "elasticsearch_hybrid",
        "configured": False,
        "connected": False,
        "healthy": False,
        "error": None,
        "connection_time": None,
        "client_type": None,
        "cluster_info": {},
        "bonsai_url_format": None
    }
    
    # V√©rifier la configuration BONSAI_URL
    if not settings.BONSAI_URL:
        logger.error("‚ùå BONSAI_URL non configur√©e")
        diagnostic["error"] = "BONSAI_URL not configured"
        return False, None, diagnostic
    
    diagnostic["configured"] = True
    
    # Analyser l'URL Bonsai
    bonsai_url = settings.BONSAI_URL.strip()
    
    # V√©rifier le format de l'URL
    if not bonsai_url.startswith(('http://', 'https://')):
        logger.error(f"‚ùå Format URL invalide: {bonsai_url[:50]}...")
        diagnostic["error"] = "Invalid URL format"
        return False, None, diagnostic
    
    # Extraire les informations pour le diagnostic (sans exposer les credentials)
    if '@' in bonsai_url:
        parts = bonsai_url.split('@')
        if len(parts) == 2:
            host_part = parts[1]
            diagnostic["bonsai_url_format"] = f"https://user:pass@{host_part}"
            safe_url = f"https://***:***@{host_part}"
        else:
            safe_url = "URL malform√©e"
    else:
        safe_url = bonsai_url
        diagnostic["bonsai_url_format"] = "URL sans authentification"
    
    logger.info(f"üîó Connexion √† Bonsai Elasticsearch: {safe_url}")
    
    try:
        start_time = time.time()
        
        # Cr√©er le client hybride
        from search_service.storage.elastic_client_hybrid import HybridElasticClient
        client = HybridElasticClient()
        
        logger.info("‚è±Ô∏è Test de connexion Elasticsearch hybride...")
        
        # Initialiser le client (cette m√©thode retourne maintenant un bool√©en)
        initialization_success = await client.initialize()
        
        connection_time = time.time() - start_time
        diagnostic["connection_time"] = round(connection_time, 3)
        
        if initialization_success and client._initialized:
            diagnostic["connected"] = True
            diagnostic["client_type"] = client.client_type
            logger.info(f"‚úÖ Connexion √©tablie en {connection_time:.3f}s via {client.client_type}")
            
            # Test de sant√© du cluster
            logger.info("ü©∫ V√©rification de la sant√© du service...")
            try:
                is_healthy = await client.is_healthy()
                diagnostic["healthy"] = is_healthy
                
                if is_healthy:
                    logger.info("üíö Service Elasticsearch sain et op√©rationnel")
                    
                    # R√©cup√©rer les informations pour le diagnostic
                    try:
                        client_info = client.get_client_info()
                        diagnostic["cluster_info"] = client_info
                            
                    except Exception as info_error:
                        logger.warning(f"‚ö†Ô∏è Impossible de r√©cup√©rer les infos: {info_error}")
                    
                    return True, client, diagnostic
                else:
                    logger.error("üíî Service Elasticsearch en mauvaise sant√©")
                    diagnostic["error"] = "Service unhealthy"
                    return False, client, diagnostic
            except Exception as health_error:
                logger.error(f"‚ùå Impossible de v√©rifier la sant√©: {health_error}")
                diagnostic["error"] = f"Health check failed: {health_error}"
                return False, client, diagnostic
        else:
            logger.error("üî¥ √âchec d'initialisation du client Elasticsearch")
            diagnostic["error"] = "Client initialization failed"
            return False, None, diagnostic
            
    except Exception as e:
        connection_time = time.time() - start_time
        diagnostic["connection_time"] = round(connection_time, 3)
        diagnostic["error"] = str(e)
        
        logger.error(f"üí• Erreur Elasticsearch apr√®s {connection_time:.3f}s:")
        logger.error(f"   Type: {type(e).__name__}")
        logger.error(f"   Message: {str(e)}")
        
        # Diagnostic sp√©cifique des erreurs
        error_str = str(e).lower()
        if "connection" in error_str or "timeout" in error_str:
            logger.error("üîå DIAGNOSTIC: Probl√®me de connectivit√© r√©seau")
            logger.error("   - V√©rifiez l'URL Bonsai")
            logger.error("   - V√©rifiez la connectivit√© r√©seau")
        elif "401" in str(e) or "403" in str(e) or "auth" in error_str:
            logger.error("üîë DIAGNOSTIC: Probl√®me d'authentification")
            logger.error("   - V√©rifiez les credentials dans BONSAI_URL")
        elif "ssl" in error_str or "certificate" in error_str:
            logger.error("üîí DIAGNOSTIC: Probl√®me SSL/TLS")
            logger.error("   - V√©rifiez les certificats SSL")
        
        return False, None, diagnostic


async def initialize_qdrant() -> Tuple[bool, Optional[Any], Dict[str, Any]]:
    """
    Initialise et teste la connexion Qdrant avec gestion d'erreur am√©lior√©e.
    
    Returns:
        Tuple[bool, Optional[QdrantClient], Dict[str, Any]]: (succ√®s, client, diagnostic)
    """
    logger.info("üéØ === INITIALISATION QDRANT ===")
    diagnostic = {
        "service": "qdrant",
        "configured": False,
        "connected": False,
        "healthy": False,
        "error": None,
        "connection_time": None,
        "collections_info": {},
        "version_info": {},
        "api_key_configured": False
    }
    
    # V√©rifier la configuration QDRANT_URL
    if not settings.QDRANT_URL:
        logger.error("‚ùå QDRANT_URL non configur√©e")
        diagnostic["error"] = "QDRANT_URL not configured"
        return False, None, diagnostic
    
    diagnostic["configured"] = True
    diagnostic["api_key_configured"] = bool(settings.QDRANT_API_KEY)
    
    # Log de la configuration
    qdrant_url = settings.QDRANT_URL.strip()
    logger.info(f"üîó Connexion √† Qdrant: {qdrant_url}")
    
    if settings.QDRANT_API_KEY:
        logger.info("üîë Authentification par API Key activ√©e")
        api_key_masked = f"{settings.QDRANT_API_KEY[:8]}...{settings.QDRANT_API_KEY[-4:]}" if len(settings.QDRANT_API_KEY) > 12 else "***"
        logger.info(f"üîê API Key: {api_key_masked}")
    else:
        logger.info("üîì Connexion sans authentification")
    
    try:
        start_time = time.time()
        
        # Cr√©er le client Qdrant
        from search_service.storage.qdrant_client import QdrantClient
        client = QdrantClient()
        
        logger.info("‚è±Ô∏è Test de connexion Qdrant...")
        
        # Initialiser le client (cette m√©thode retourne maintenant un bool√©en)
        initialization_success = await client.initialize()
        
        connection_time = time.time() - start_time
        diagnostic["connection_time"] = round(connection_time, 3)
        
        if initialization_success and client._initialized:
            diagnostic["connected"] = True
            logger.info(f"‚úÖ Connexion √©tablie en {connection_time:.3f}s")
            
            # Test de sant√©
            logger.info("ü©∫ V√©rification de la sant√© de Qdrant...")
            try:
                is_healthy = await client.is_healthy()
                diagnostic["healthy"] = is_healthy
                
                if is_healthy:
                    logger.info("üíö Service Qdrant sain et op√©rationnel")
                    
                    # R√©cup√©rer les informations pour le diagnostic
                    try:
                        collection_info = await client.get_collection_info()
                        diagnostic["collections_info"] = collection_info
                        
                        # Informations sur les collections disponibles
                        if client.client:
                            collections = await client.client.get_collections()
                            collection_names = [col.name for col in collections.collections]
                            diagnostic["collections_info"]["available_collections"] = collection_names
                            diagnostic["collections_info"]["target_collection"] = client.collection_name
                            diagnostic["collections_info"]["target_exists"] = client.collection_name in collection_names
                            
                            # Informations du cluster
                            cluster_info = await client.get_cluster_info()
                            diagnostic["version_info"] = cluster_info
                            
                    except Exception as info_error:
                        logger.warning(f"‚ö†Ô∏è Impossible de r√©cup√©rer les infos collections: {info_error}")
                    
                    return True, client, diagnostic
                else:
                    logger.error("üíî Service Qdrant en mauvaise sant√©")
                    diagnostic["error"] = "Service unhealthy"
                    return False, client, diagnostic
            except Exception as health_error:
                logger.error(f"‚ùå Impossible de v√©rifier la sant√©: {health_error}")
                diagnostic["error"] = f"Health check failed: {health_error}"
                return False, client, diagnostic
        else:
            logger.error("üî¥ √âchec d'initialisation du client Qdrant")
            diagnostic["error"] = "Client initialization failed"
            return False, None, diagnostic
            
    except Exception as e:
        connection_time = time.time() - start_time
        diagnostic["connection_time"] = round(connection_time, 3)
        diagnostic["error"] = str(e)
        
        logger.error(f"üí• Erreur Qdrant apr√®s {connection_time:.3f}s:")
        logger.error(f"   Type: {type(e).__name__}")
        logger.error(f"   Message: {str(e)}")
        
        # Diagnostic sp√©cifique des erreurs
        error_str = str(e).lower()
        if "connection" in error_str or "timeout" in error_str:
            logger.error("üîå DIAGNOSTIC: Probl√®me de connectivit√© r√©seau")
            logger.error("   - V√©rifiez l'URL Qdrant")
            logger.error("   - V√©rifiez la connectivit√© r√©seau")
        elif "401" in str(e) or "403" in str(e) or "auth" in error_str:
            logger.error("üîë DIAGNOSTIC: Probl√®me d'authentification")
            logger.error("   - V√©rifiez QDRANT_API_KEY")
        elif "ssl" in error_str or "certificate" in error_str:
            logger.error("üîí DIAGNOSTIC: Probl√®me SSL/TLS")
        
        return False, None, diagnostic


async def test_clients_connectivity() -> Dict[str, Any]:
    """
    Teste la connectivit√© des deux clients de mani√®re ind√©pendante.
    
    Returns:
        Dict[str, Any]: Rapport de test de connectivit√©
    """
    logger.info("üß™ === TEST DE CONNECTIVIT√â ===")
    
    test_results = {
        "timestamp": time.time(),
        "elasticsearch": {
            "tested": False,
            "success": False,
            "response_time": None,
            "error": None
        },
        "qdrant": {
            "tested": False,
            "success": False,
            "response_time": None,
            "error": None
        }
    }
    
    # Test Elasticsearch
    if settings.BONSAI_URL:
        logger.info("üîç Test de connectivit√© Elasticsearch...")
        try:
            start_time = time.time()
            
            # Test basique avec aiohttp pour valider l'URL
            import aiohttp
            async with aiohttp.ClientSession() as session:
                async with session.get(settings.BONSAI_URL, timeout=10) as response:
                    response_time = time.time() - start_time
                    test_results["elasticsearch"]["tested"] = True
                    test_results["elasticsearch"]["response_time"] = round(response_time, 3)
                    test_results["elasticsearch"]["success"] = response.status == 200
                    
                    if response.status == 200:
                        logger.info(f"‚úÖ Elasticsearch r√©pond en {response_time:.3f}s")
                    else:
                        logger.warning(f"‚ö†Ô∏è Elasticsearch r√©pond avec status {response.status}")
                        
        except Exception as e:
            test_results["elasticsearch"]["tested"] = True
            test_results["elasticsearch"]["error"] = str(e)
            logger.error(f"‚ùå Test Elasticsearch √©chou√©: {e}")
    else:
        test_results["elasticsearch"]["error"] = "BONSAI_URL not configured"
        logger.warning("‚ö†Ô∏è BONSAI_URL non configur√©e - test ignor√©")
    
    # Test Qdrant
    if settings.QDRANT_URL:
        logger.info("üéØ Test de connectivit√© Qdrant...")
        try:
            start_time = time.time()
            
            # Test basique avec aiohttp
            import aiohttp
            headers = {}
            if settings.QDRANT_API_KEY:
                headers["api-key"] = settings.QDRANT_API_KEY
            
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{settings.QDRANT_URL}/collections", headers=headers, timeout=10) as response:
                    response_time = time.time() - start_time
                    test_results["qdrant"]["tested"] = True
                    test_results["qdrant"]["response_time"] = round(response_time, 3)
                    test_results["qdrant"]["success"] = response.status == 200
                    
                    if response.status == 200:
                        logger.info(f"‚úÖ Qdrant r√©pond en {response_time:.3f}s")
                    else:
                        logger.warning(f"‚ö†Ô∏è Qdrant r√©pond avec status {response.status}")
                        
        except Exception as e:
            test_results["qdrant"]["tested"] = True
            test_results["qdrant"]["error"] = str(e)
            logger.error(f"‚ùå Test Qdrant √©chou√©: {e}")
    else:
        test_results["qdrant"]["error"] = "QDRANT_URL not configured"
        logger.warning("‚ö†Ô∏è QDRANT_URL non configur√©e - test ignor√©")
    
    # R√©sum√©
    elasticsearch_ok = test_results["elasticsearch"]["success"]
    qdrant_ok = test_results["qdrant"]["success"]
    
    if elasticsearch_ok and qdrant_ok:
        logger.info("üéâ Les deux services sont accessibles")
    elif elasticsearch_ok:
        logger.warning("‚ö†Ô∏è Seul Elasticsearch est accessible")
    elif qdrant_ok:
        logger.warning("‚ö†Ô∏è Seul Qdrant est accessible")
    else:
        logger.error("üö® Aucun service n'est accessible")
    
    return test_results


def validate_environment_configuration() -> Dict[str, Any]:
    """
    Valide la configuration de l'environnement avant l'initialisation.
    
    Returns:
        Dict[str, Any]: Rapport de validation
    """
    logger.info("‚öôÔ∏è === VALIDATION DE LA CONFIGURATION ===")
    
    validation = {
        "bonsai_url": {
            "configured": bool(settings.BONSAI_URL),
            "format_valid": False,
            "has_credentials": False,
            "error": None
        },
        "qdrant_url": {
            "configured": bool(settings.QDRANT_URL),
            "format_valid": False,
            "has_api_key": bool(settings.QDRANT_API_KEY),
            "error": None
        },
        "ai_services": {
            "openai_configured": bool(settings.OPENAI_API_KEY),
            "cohere_configured": bool(getattr(settings, 'COHERE_KEY', None)),
            "deepseek_configured": bool(getattr(settings, 'DEEPSEEK_API_KEY', None))
        },
        "summary": {
            "ready_for_elasticsearch": False,
            "ready_for_qdrant": False,
            "critical_issues": []
        }
    }
    
    # Validation BONSAI_URL
    if settings.BONSAI_URL:
        url = settings.BONSAI_URL.strip()
        if url.startswith(('http://', 'https://')):
            validation["bonsai_url"]["format_valid"] = True
            validation["bonsai_url"]["has_credentials"] = '@' in url
            validation["summary"]["ready_for_elasticsearch"] = True
            logger.info("‚úÖ BONSAI_URL configur√©e correctement")
        else:
            validation["bonsai_url"]["error"] = "Format URL invalide"
            validation["summary"]["critical_issues"].append("BONSAI_URL format invalide")
            logger.error("‚ùå BONSAI_URL format invalide")
    else:
        validation["bonsai_url"]["error"] = "Non configur√©e"
        validation["summary"]["critical_issues"].append("BONSAI_URL manquante")
        logger.error("‚ùå BONSAI_URL non configur√©e")
    
    # Validation QDRANT_URL
    if settings.QDRANT_URL:
        url = settings.QDRANT_URL.strip()
        if url.startswith(('http://', 'https://')):
            validation["qdrant_url"]["format_valid"] = True
            validation["summary"]["ready_for_qdrant"] = True
            logger.info("‚úÖ QDRANT_URL configur√©e correctement")
            
            if settings.QDRANT_API_KEY:
                logger.info("‚úÖ QDRANT_API_KEY configur√©e")
            else:
                logger.warning("‚ö†Ô∏è QDRANT_API_KEY non configur√©e (connexion non s√©curis√©e)")
        else:
            validation["qdrant_url"]["error"] = "Format URL invalide"
            validation["summary"]["critical_issues"].append("QDRANT_URL format invalide")
            logger.error("‚ùå QDRANT_URL format invalide")
    else:
        validation["qdrant_url"]["error"] = "Non configur√©e"
        validation["summary"]["critical_issues"].append("QDRANT_URL manquante")
        logger.error("‚ùå QDRANT_URL non configur√©e")
    
    # Validation des services IA
    if validation["ai_services"]["openai_configured"]:
        logger.info("‚úÖ OpenAI API configur√©e (embeddings disponibles)")
    else:
        logger.warning("‚ö†Ô∏è OpenAI API non configur√©e (pas d'embeddings)")
    
    if validation["ai_services"]["cohere_configured"]:
        logger.info("‚úÖ Cohere API configur√©e (reranking disponible)")
    else:
        logger.warning("‚ö†Ô∏è Cohere API non configur√©e (pas de reranking)")
    
    if validation["ai_services"]["deepseek_configured"]:
        logger.info("‚úÖ DeepSeek API configur√©e")
    else:
        logger.warning("‚ö†Ô∏è DeepSeek API non configur√©e")
    
    # R√©sum√©
    if validation["summary"]["ready_for_elasticsearch"] and validation["summary"]["ready_for_qdrant"]:
        logger.info("üéâ Configuration valide pour les deux services")
    elif validation["summary"]["critical_issues"]:
        logger.error(f"üö® Probl√®mes critiques d√©tect√©s: {len(validation['summary']['critical_issues'])}")
        for issue in validation["summary"]["critical_issues"]:
            logger.error(f"   - {issue}")
    
    return validation


async def initialize_search_clients() -> Dict[str, Any]:
    """
    Initialise les clients de recherche avec gestion d'erreur compl√®te.
    
    Returns:
        Dict[str, Any]: Rapport d'initialisation complet
    """
    logger.info("üöÄ === INITIALISATION DES CLIENTS DE RECHERCHE ===")
    
    initialization_report = {
        "timestamp": time.time(),
        "validation": {},
        "connectivity_test": {},
        "elasticsearch": {},
        "qdrant": {},
        "summary": {
            "elasticsearch_ready": False,
            "qdrant_ready": False,
            "total_ready": 0,
            "status": "FAILED"
        }
    }
    
    try:
        # 1. Validation de la configuration
        logger.info("üìã √âtape 1: Validation de la configuration")
        validation = validate_environment_configuration()
        initialization_report["validation"] = validation
        
        if validation["summary"]["critical_issues"]:
            logger.error("‚ùå Arr√™t √† cause de probl√®mes de configuration critiques")
            return initialization_report
        
        # 2. Test de connectivit√© basique
        logger.info("üåê √âtape 2: Test de connectivit√© basique")
        connectivity_test = await test_clients_connectivity()
        initialization_report["connectivity_test"] = connectivity_test
        
        # 3. Initialisation d'Elasticsearch
        logger.info("üîç √âtape 3: Initialisation d'Elasticsearch")
        elastic_success, elastic_client, elastic_diag = await initialize_elasticsearch_hybrid()
        initialization_report["elasticsearch"] = {
            "success": elastic_success,
            "client_initialized": elastic_client is not None,
            "diagnostic": elastic_diag
        }
        initialization_report["summary"]["elasticsearch_ready"] = elastic_success
        
        # 4. Initialisation de Qdrant
        logger.info("üéØ √âtape 4: Initialisation de Qdrant")
        qdrant_success, qdrant_client, qdrant_diag = await initialize_qdrant()
        initialization_report["qdrant"] = {
            "success": qdrant_success,
            "client_initialized": qdrant_client is not None,
            "diagnostic": qdrant_diag
        }
        initialization_report["summary"]["qdrant_ready"] = qdrant_success
        
        # 5. Calcul du statut final
        ready_count = sum([
            initialization_report["summary"]["elasticsearch_ready"],
            initialization_report["summary"]["qdrant_ready"]
        ])
        initialization_report["summary"]["total_ready"] = ready_count
        
        if ready_count == 2:
            initialization_report["summary"]["status"] = "OPTIMAL"
            logger.info("üéâ Initialisation OPTIMALE: Tous les services pr√™ts")
        elif ready_count == 1:
            initialization_report["summary"]["status"] = "DEGRADED"
            logger.warning("‚ö†Ô∏è Initialisation D√âGRAD√âE: Service partiel")
        else:
            initialization_report["summary"]["status"] = "FAILED"
            logger.error("üö® Initialisation √âCHOU√âE: Aucun service pr√™t")
        
        # 6. Retourner les clients initialis√©s
        initialization_report["clients"] = {
            "elasticsearch": elastic_client if elastic_success else None,
            "qdrant": qdrant_client if qdrant_success else None
        }
        
        return initialization_report
        
    except Exception as e:
        logger.error(f"üí• Erreur lors de l'initialisation: {e}", exc_info=True)
        initialization_report["summary"]["status"] = "ERROR"
        initialization_report["error"] = str(e)
        return initialization_report


def log_initialization_summary(report: Dict[str, Any]):
    """
    Affiche un r√©sum√© d√©taill√© de l'initialisation.
    
    Args:
        report: Rapport d'initialisation
    """
    logger.info("=" * 100)
    logger.info("üìä R√âSUM√â DE L'INITIALISATION")
    logger.info("=" * 100)
    
    # Statut global
    status = report["summary"]["status"]
    status_icons = {
        "OPTIMAL": "üéâ",
        "DEGRADED": "‚ö†Ô∏è",
        "FAILED": "üö®",
        "ERROR": "üí•"
    }
    icon = status_icons.get(status, "‚ùì")
    logger.info(f"{icon} Statut global: {status}")
    
    # D√©tails par service
    logger.info("üìã D√©tails par service:")
    
    # Elasticsearch
    elastic_ready = report["summary"]["elasticsearch_ready"]
    elastic_icon = "‚úÖ" if elastic_ready else "‚ùå"
    logger.info(f"   {elastic_icon} Elasticsearch: {'PR√äT' if elastic_ready else '√âCHEC'}")
    
    if "elasticsearch" in report and "diagnostic" in report["elasticsearch"]:
        diag = report["elasticsearch"]["diagnostic"]
        if diag.get("connection_time"):
            logger.info(f"      ‚è±Ô∏è Temps de connexion: {diag['connection_time']}s")
        if diag.get("client_type"):
            logger.info(f"      üîß Client utilis√©: {diag['client_type']}")
        if diag.get("error"):
            logger.info(f"      ‚ùå Erreur: {diag['error']}")
    
    # Qdrant
    qdrant_ready = report["summary"]["qdrant_ready"]
    qdrant_icon = "‚úÖ" if qdrant_ready else "‚ùå"
    logger.info(f"   {qdrant_icon} Qdrant: {'PR√äT' if qdrant_ready else '√âCHEC'}")
    
    if "qdrant" in report and "diagnostic" in report["qdrant"]:
        diag = report["qdrant"]["diagnostic"]
        if diag.get("connection_time"):
            logger.info(f"      ‚è±Ô∏è Temps de connexion: {diag['connection_time']}s")
        if diag.get("collections_info", {}).get("available_collections"):
            collections = diag["collections_info"]["available_collections"]
            logger.info(f"      üìö Collections: {len(collections)} disponibles")
        if diag.get("error"):
            logger.info(f"      ‚ùå Erreur: {diag['error']}")
    
    # Capacit√©s disponibles
    logger.info("üîß Capacit√©s disponibles:")
    if elastic_ready and qdrant_ready:
        logger.info("   ‚úÖ Recherche hybride (lexicale + s√©mantique)")
        logger.info("   ‚úÖ Reranking intelligent")
        logger.info("   ‚úÖ Toutes les fonctionnalit√©s")
    elif elastic_ready:
        logger.info("   ‚úÖ Recherche lexicale uniquement")
        logger.info("   ‚ùå Recherche s√©mantique indisponible")
    elif qdrant_ready:
        logger.info("   ‚ùå Recherche lexicale indisponible")
        logger.info("   ‚úÖ Recherche s√©mantique uniquement")
    else:
        logger.info("   ‚ùå Aucune recherche disponible")
    
    # Recommandations
    logger.info("üí° Recommandations:")
    if status == "OPTIMAL":
        logger.info("   üéØ Service op√©rationnel - Aucune action requise")
    elif status == "DEGRADED":
        logger.info("   üîß V√©rifier la configuration du service d√©faillant")
        logger.info("   üìû Contacter l'√©quipe infrastructure si n√©cessaire")
    elif status == "FAILED":
        logger.info("   üö® V√©rifier les variables d'environnement")
        logger.info("   üåê Tester la connectivit√© r√©seau")
        logger.info("   üîë Valider les credentials d'authentification")
    
    logger.info("=" * 100)


async def create_collections_if_needed(qdrant_client) -> bool:
    """
    Cr√©e les collections Qdrant n√©cessaires si elles n'existent pas.
    
    Args:
        qdrant_client: Client Qdrant initialis√©
        
    Returns:
        bool: Succ√®s de la cr√©ation/v√©rification
    """
    if not qdrant_client or not qdrant_client._initialized:
        logger.error("‚ùå Client Qdrant non disponible pour la cr√©ation de collections")
        return False
    
    logger.info("üîß === CR√âATION DES COLLECTIONS QDRANT ===")
    
    try:
        # V√©rifier si la collection principale existe
        exists = await qdrant_client.collection_exists()
        
        if not exists:
            logger.info(f"üèóÔ∏è Cr√©ation de la collection '{qdrant_client.collection_name}'...")
            
            # Cr√©er la collection avec les param√®tres par d√©faut
            success = await qdrant_client.create_collection_if_not_exists(
                vector_size=1536,  # Taille pour text-embedding-3-small d'OpenAI
                distance_metric="Cosine"
            )
            
            if success:
                logger.info("‚úÖ Collection cr√©√©e avec succ√®s")
                return True
            else:
                logger.error("‚ùå √âchec de la cr√©ation de la collection")
                return False
        else:
            logger.info(f"‚úÖ Collection '{qdrant_client.collection_name}' existe d√©j√†")
            return True
            
    except Exception as e:
        logger.error(f"üí• Erreur lors de la cr√©ation des collections: {e}")
        return False


async def validate_clients_functionality(elastic_client, qdrant_client) -> Dict[str, Any]:
    """
    Valide la fonctionnalit√© des clients avec des tests simples.
    
    Args:
        elastic_client: Client Elasticsearch initialis√©
        qdrant_client: Client Qdrant initialis√©
        
    Returns:
        Dict[str, Any]: Rapport de validation
    """
    logger.info("üß™ === VALIDATION DE LA FONCTIONNALIT√â ===")
    
    validation_results = {
        "timestamp": time.time(),
        "elasticsearch": {
            "tested": False,
            "functional": False,
            "capabilities": [],
            "error": None
        },
        "qdrant": {
            "tested": False,
            "functional": False,
            "capabilities": [],
            "error": None
        },
        "overall_status": "FAILED"
    }
    
    # Test Elasticsearch
    if elastic_client and elastic_client._initialized:
        logger.info("üîç Test fonctionnalit√© Elasticsearch...")
        validation_results["elasticsearch"]["tested"] = True
        
        try:
            # Test de sant√©
            is_healthy = await elastic_client.is_healthy()
            if is_healthy:
                validation_results["elasticsearch"]["capabilities"].append("health_check")
            
            # Test d'informations sur l'index
            index_info = await elastic_client.get_index_info()
            if not index_info.get("error"):
                validation_results["elasticsearch"]["capabilities"].append("index_management")
            
            # Test de comptage (m√™me si l'index est vide)
            count = await elastic_client.count_documents()
            if count >= 0:  # M√™me 0 est valide
                validation_results["elasticsearch"]["capabilities"].append("document_counting")
            
            # Si au moins une capacit√© fonctionne
            if validation_results["elasticsearch"]["capabilities"]:
                validation_results["elasticsearch"]["functional"] = True
                logger.info("‚úÖ Elasticsearch fonctionnel")
            else:
                logger.warning("‚ö†Ô∏è Elasticsearch partiellement fonctionnel")
                
        except Exception as e:
            validation_results["elasticsearch"]["error"] = str(e)
            logger.error(f"‚ùå Test Elasticsearch √©chou√©: {e}")
    else:
        logger.warning("‚ö†Ô∏è Elasticsearch non disponible pour les tests")
    
    # Test Qdrant
    if qdrant_client and qdrant_client._initialized:
        logger.info("üéØ Test fonctionnalit√© Qdrant...")
        validation_results["qdrant"]["tested"] = True
        
        try:
            # Test de sant√©
            is_healthy = await qdrant_client.is_healthy()
            if is_healthy:
                validation_results["qdrant"]["capabilities"].append("health_check")
            
            # Test de liste des collections
            collections = await qdrant_client.get_collections_list()
            if isinstance(collections, list):
                validation_results["qdrant"]["capabilities"].append("collection_management")
            
            # Test d'existence de collection
            exists = await qdrant_client.collection_exists()
            validation_results["qdrant"]["capabilities"].append("collection_verification")
            
            # Test de comptage (m√™me si la collection est vide)
            if exists:
                count = await qdrant_client.count_points()
                if count >= 0:  # M√™me 0 est valide
                    validation_results["qdrant"]["capabilities"].append("point_counting")
            
            # Si au moins une capacit√© fonctionne
            if validation_results["qdrant"]["capabilities"]:
                validation_results["qdrant"]["functional"] = True
                logger.info("‚úÖ Qdrant fonctionnel")
            else:
                logger.warning("‚ö†Ô∏è Qdrant partiellement fonctionnel")
                
        except Exception as e:
            validation_results["qdrant"]["error"] = str(e)
            logger.error(f"‚ùå Test Qdrant √©chou√©: {e}")
    else:
        logger.warning("‚ö†Ô∏è Qdrant non disponible pour les tests")
    
    # D√©terminer le statut global
    elasticsearch_ok = validation_results["elasticsearch"]["functional"]
    qdrant_ok = validation_results["qdrant"]["functional"]
    
    if elasticsearch_ok and qdrant_ok:
        validation_results["overall_status"] = "OPTIMAL"
        logger.info("üéâ Tous les clients sont fonctionnels")
    elif elasticsearch_ok or qdrant_ok:
        validation_results["overall_status"] = "DEGRADED"
        logger.warning("‚ö†Ô∏è Au moins un client est fonctionnel")
    else:
        validation_results["overall_status"] = "FAILED"
        logger.error("üö® Aucun client n'est fonctionnel")
    
    return validation_results


async def run_startup_diagnostics() -> Dict[str, Any]:
    """
    Lance un diagnostic complet au d√©marrage.
    
    Returns:
        Dict[str, Any]: Rapport de diagnostic complet
    """
    logger.info("üî¨ === DIAGNOSTIC COMPLET DE D√âMARRAGE ===")
    
    diagnostic_start = time.time()
    
    # Rapport principal
    full_diagnostic = {
        "timestamp": time.time(),
        "version": "2.0.0",
        "environment": {
            "python_version": None,
            "dependencies": {},
            "system_info": {}
        },
        "configuration_validation": {},
        "connectivity_tests": {},
        "client_initialization": {},
        "functionality_validation": {},
        "recommendations": [],
        "duration_seconds": 0,
        "overall_status": "UNKNOWN"
    }
    
    try:
        # 1. Informations syst√®me
        import sys
        import platform
        
        full_diagnostic["environment"]["python_version"] = sys.version
        full_diagnostic["environment"]["system_info"] = {
            "platform": platform.platform(),
            "architecture": platform.architecture(),
            "processor": platform.processor()
        }
        
        # 2. V√©rification des d√©pendances
        dependencies_status = {}
        required_packages = ["elasticsearch", "qdrant_client", "aiohttp", "fastapi"]
        
        for package in required_packages:
            try:
                __import__(package)
                dependencies_status[package] = "available"
            except ImportError:
                dependencies_status[package] = "missing"
        
        full_diagnostic["environment"]["dependencies"] = dependencies_status
        
        # 3. Validation de la configuration
        config_validation = validate_environment_configuration()
        full_diagnostic["configuration_validation"] = config_validation
        
        # 4. Tests de connectivit√©
        connectivity_tests = await test_clients_connectivity()
        full_diagnostic["connectivity_tests"] = connectivity_tests
        
        # 5. Initialisation des clients
        client_init = await initialize_search_clients()
        full_diagnostic["client_initialization"] = client_init
        
        # 6. Validation de la fonctionnalit√©
        if client_init.get("clients"):
            elastic_client = client_init["clients"].get("elasticsearch")
            qdrant_client = client_init["clients"].get("qdrant")
            
            functionality_validation = await validate_clients_functionality(elastic_client, qdrant_client)
            full_diagnostic["functionality_validation"] = functionality_validation
        
        # 7. G√©n√©ration des recommandations
        recommendations = generate_recommendations(full_diagnostic)
        full_diagnostic["recommendations"] = recommendations
        
        # 8. D√©termination du statut global
        overall_status = determine_overall_status(full_diagnostic)
        full_diagnostic["overall_status"] = overall_status
        
        # 9. Dur√©e totale
        diagnostic_duration = time.time() - diagnostic_start
        full_diagnostic["duration_seconds"] = round(diagnostic_duration, 2)
        
        logger.info(f"‚úÖ Diagnostic complet termin√© en {diagnostic_duration:.2f}s")
        logger.info(f"üìä Statut global: {overall_status}")
        
        return full_diagnostic
        
    except Exception as e:
        logger.error(f"üí• Erreur lors du diagnostic: {e}", exc_info=True)
        full_diagnostic["error"] = str(e)
        full_diagnostic["overall_status"] = "ERROR"
        full_diagnostic["duration_seconds"] = round(time.time() - diagnostic_start, 2)
        return full_diagnostic


def generate_recommendations(diagnostic: Dict[str, Any]) -> List[str]:
    """
    G√©n√®re des recommandations bas√©es sur le diagnostic.
    
    Args:
        diagnostic: Rapport de diagnostic complet
        
    Returns:
        List[str]: Liste de recommandations
    """
    recommendations = []
    
    # Recommandations de configuration
    config_validation = diagnostic.get("configuration_validation", {})
    if config_validation.get("summary", {}).get("critical_issues"):
        recommendations.append("üîß Corriger les probl√®mes de configuration critiques")
        recommendations.append("üìã V√©rifier les variables d'environnement BONSAI_URL et QDRANT_URL")
    
    # Recommandations de connectivit√©
    connectivity = diagnostic.get("connectivity_tests", {})
    if not connectivity.get("elasticsearch", {}).get("success"):
        recommendations.append("üåê V√©rifier la connectivit√© r√©seau vers Elasticsearch/Bonsai")
        recommendations.append("üîë Valider les credentials d'authentification Bonsai")
    
    if not connectivity.get("qdrant", {}).get("success"):
        recommendations.append("üåê V√©rifier la connectivit√© r√©seau vers Qdrant")
        recommendations.append("üîë Valider QDRANT_API_KEY si requis")
    
    # Recommandations d'initialisation
    client_init = diagnostic.get("client_initialization", {})
    if not client_init.get("summary", {}).get("elasticsearch_ready"):
        recommendations.append("üîç Investiguer les probl√®mes d'initialisation Elasticsearch")
    
    if not client_init.get("summary", {}).get("qdrant_ready"):
        recommendations.append("üéØ Investiguer les probl√®mes d'initialisation Qdrant")
        recommendations.append("üìö V√©rifier que les collections Qdrant sont cr√©√©es")
    
    # Recommandations de fonctionnalit√©
    functionality = diagnostic.get("functionality_validation", {})
    if functionality.get("overall_status") == "DEGRADED":
        recommendations.append("‚öôÔ∏è Tester les fonctionnalit√©s en mode d√©grad√©")
        recommendations.append("üìà Surveiller les performances avec un seul moteur")
    
    # Recommandations g√©n√©rales
    if not recommendations:
        recommendations.append("‚úÖ Configuration optimale - aucune action requise")
        recommendations.append("üìä Surveiller les m√©triques de performance")
        recommendations.append("üîÑ Effectuer des tests p√©riodiques")
    
    return recommendations


def determine_overall_status(diagnostic: Dict[str, Any]) -> str:
    """
    D√©termine le statut global bas√© sur tous les tests.
    
    Args:
        diagnostic: Rapport de diagnostic complet
        
    Returns:
        str: Statut global (OPTIMAL, DEGRADED, FAILED, ERROR)
    """
    # V√©rifier s'il y a eu une erreur
    if "error" in diagnostic:
        return "ERROR"
    
    # V√©rifier l'initialisation des clients
    client_init = diagnostic.get("client_initialization", {})
    init_status = client_init.get("summary", {}).get("status", "FAILED")
    
    # V√©rifier la fonctionnalit√©
    functionality = diagnostic.get("functionality_validation", {})
    func_status = functionality.get("overall_status", "FAILED")
    
    # Combiner les statuts
    if init_status == "OPTIMAL" and func_status == "OPTIMAL":
        return "OPTIMAL"
    elif init_status in ["OPTIMAL", "DEGRADED"] and func_status in ["OPTIMAL", "DEGRADED"]:
        return "DEGRADED"
    elif init_status == "ERROR" or func_status == "ERROR":
        return "ERROR"
    else:
        return "FAILED"


def log_diagnostic_summary(diagnostic: Dict[str, Any]):
    """
    Affiche un r√©sum√© du diagnostic complet.
    
    Args:
        diagnostic: Rapport de diagnostic complet
    """
    logger.info("=" * 120)
    logger.info("üî¨ RAPPORT DE DIAGNOSTIC COMPLET")
    logger.info("=" * 120)
    
    # En-t√™te
    status = diagnostic.get("overall_status", "UNKNOWN")
    duration = diagnostic.get("duration_seconds", 0)
    
    status_icons = {
        "OPTIMAL": "üéâ",
        "DEGRADED": "‚ö†Ô∏è",
        "FAILED": "üö®",
        "ERROR": "üí•",
        "UNKNOWN": "‚ùì"
    }
    
    icon = status_icons.get(status, "‚ùì")
    logger.info(f"{icon} Statut global: {status}")
    logger.info(f"‚è±Ô∏è Dur√©e du diagnostic: {duration}s")
    logger.info(f"üìÖ Timestamp: {diagnostic.get('timestamp', 'N/A')}")
    
    # Environnement
    env = diagnostic.get("environment", {})
    if env:
        logger.info("üñ•Ô∏è Environnement:")
        logger.info(f"   üêç Python: {env.get('python_version', 'N/A')}")
        
        deps = env.get("dependencies", {})
        for pkg, status in deps.items():
            dep_icon = "‚úÖ" if status == "available" else "‚ùå"
            logger.info(f"   {dep_icon} {pkg}: {status}")
    
    # Configuration
    config = diagnostic.get("configuration_validation", {})
    if config:
        issues = config.get("summary", {}).get("critical_issues", [])
        if issues:
            logger.info("‚ùå Probl√®mes de configuration:")
            for issue in issues:
                logger.info(f"   - {issue}")
        else:
            logger.info("‚úÖ Configuration valide")
    
    # Connectivit√©
    connectivity = diagnostic.get("connectivity_tests", {})
    if connectivity:
        logger.info("üåê Tests de connectivit√©:")
        
        for service in ["elasticsearch", "qdrant"]:
            test = connectivity.get(service, {})
            if test.get("tested"):
                success = test.get("success", False)
                time_ms = test.get("response_time", 0) * 1000
                icon = "‚úÖ" if success else "‚ùå"
                logger.info(f"   {icon} {service.capitalize()}: {time_ms:.0f}ms")
            else:
                logger.info(f"   ‚ö™ {service.capitalize()}: Non test√©")
    
    # Recommandations
    recommendations = diagnostic.get("recommendations", [])
    if recommendations:
        logger.info("üí° Recommandations:")
        for rec in recommendations[:5]:  # Limiter √† 5 recommandations
            logger.info(f"   {rec}")
        
        if len(recommendations) > 5:
            logger.info(f"   ... et {len(recommendations) - 5} autres recommandations")
    
    logger.info("=" * 120)